<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>US Homicides</title>

    <!--Load jQuery and fullpage tags -->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/3.0.1/fullpage.min.js"></script>

    <!-- load d3 -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
    <script src="https://d3js.org/topojson.v2.min.js"></script>

    <!--We will overide some default styles here -->
    <link rel="stylesheet" href='styles.css'>
    <!-- Adding fullpage.css is essential-->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/3.0.1/fullpage.min.css" />
  </head>
  <body>

    <div id="fullpage">
      <div class="section">
        <p>Homicides By State</p>
        <label><input id="showCumulativeCheckbox" type="checkbox" onchange="drawMap()"/>Show Cumulative Totals</label>
        <input type="range" min="2007" max="2017" value="2007" id="yearSlider" oninput="drawMap()" onchange="drawMap()">
        <p id="yearLabel"></p>
        <svg id="yearmap" width="960", height="600"></svg>
      </div>
      <div class="section">
        <p>Section 2</p>
        <div id="section2Tooltip" class="tooltip"></div>
        <svg id="overviewCircles" width="960", height="960"></svg>
      </div>
      <div class="section">
        <p>Section 3</p>
        <svg id="stateCircles" width="960", height="960"></svg>
      </div>
    </div>

    <!--Custom script -->
    <script type="text/javascript">
      $(document).ready(function(){
        $("#fullpage").fullpage({
          //fullpage options
          licenseKey:"OPEN-SOURCE-GPLV3-LICENSE"
        });  
        loadData();
        drawOverViewCirlces();
      });

      function loadData() {
        // this is run after page is ready so I can select all the svg elements I need
        mapSvg = d3.select("#yearmap");
        overviewCirclesSvg = d3.select("#overviewCircles");

        d3.queue()
        .defer(d3.json, "https://d3js.org/us-10m.v1.json")
        .defer(d3.tsv, "https://gist.githubusercontent.com/mbostock/4090846/raw/07e73f3c2d21558489604a0bc434b3a5cf41a867/us-state-names.tsv", function(d) { statesMap.set(d.code, d.id)})
        .defer(d3.csv, "count_by_year_and_state.csv", buildHomicides)
        .await(usLoaded);


      }

      //This chunk is the map on the first slide
      var color = d3.scaleThreshold();
      var homicidesState = {};
      var statesMap = d3.map();
      var path = d3.geoPath();
      var mapSvg = d3.select("#yearmap");
      var us = {};

      function buildColorRange(year, showCumulativeTotals) {
        var minCount = Number.MAX_SAFE_INTEGER;
        var maxCount = Number.MIN_SAFE_INTEGER;

        for (var state in homicidesState) {
          var years = homicidesState[state];

          var count = -1;
          if(showCumulativeTotals) {
            count = getCumulativeCountForState(state, year);
          }
          else if(year in years) {
            count = parseInt(years[year]);
          }

          if(count == -1) continue;

          if(count > maxCount) {
            maxCount = count;
          }

          if(count < minCount) {
            minCount = count;
          } 
        }

        color = d3.scaleThreshold()
          .domain(d3.range(minCount, maxCount))
          .range(d3.schemeBlues[5]);
      }

      function getCumulativeCountForState(state, endYear) {
        var total = -1;
        for (checkYear = 2007; checkYear <= endYear; checkYear++) {
          if(checkYear in homicidesState[state]) {
            if(total == -1) total += 1; //first time to get to 0
            total += parseInt(homicidesState[state][checkYear]);
          }
        }
        return total;
      }

      function getColor(stateId, year, showCumulativeTotals) {
        var state = parseInt(stateId)
        if (state in homicidesState) {

          if(showCumulativeTotals) {
            var total = getCumulativeCountForState(state, year);
            if(total != 0)
              return color(total);
          }
          else if(year in homicidesState[state]) {
            return color(homicidesState[state][year]);
          }
        }
        return "gray";
      }

      function drawMap() {
        var year = parseInt($("#yearSlider").val());
        var showCumulativeTotals = $("#showCumulativeCheckbox").is(":checked");

        if(showCumulativeTotals) {
          $("#yearLabel").text("Years: 2007-" + year);
        }
        else {
          $("#yearLabel").text("Year: " + year);
        }

        buildColorRange(year, showCumulativeTotals);

        var join = mapSvg.selectAll("path").data(topojson.feature(us, us.objects.states).features);
        join.enter().append("path").merge(join)
          .attr("fill", function(d) { return getColor(d.id, year, showCumulativeTotals) })
          .attr("d", path);

        mapSvg.append("path")
          .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
          .attr("class", "state-borders")
          .attr("d", path);
      }
      
      function buildHomicides(homicideData, error) {
          var stateId = statesMap.get(homicideData.state);
          if(!(stateId in homicidesState)) {
            homicidesState[stateId] = {};
          }
          homicidesState[stateId][homicideData.year] = homicideData.count; 
        }

      function usLoaded(error, usLoad) {
        if(error) throw error;
        us = usLoad;
        drawMap();
      }


      //this chunk is the first set of circles (not broken down by type)

      //harcoded data
      var countsByCategory = {
        arrest: 25674,
        withoutArrest: 2922,
        open: 23583 
      };
      var totalHomicides = countsByCategory.arrest + countsByCategory.withoutArrest + countsByCategory.open;
      var hardCodedColors = {
        arrest: "green",
        withoutArrest: "yellow",
        open: "red"
      };
      var hardCodedXValues = {
        arrest: 220,
        withoutArrest: 500,
        open: 750
      };
      var hardCodedLabels = {
        arrest: "Arrest",
        withoutArrest: "No Arrest",
        open: "Open"
      };

      var overviewCirclesSvg = d3.select("#overviewCircles");

      function drawOverViewCirlces() {
        var svgHeight = $("#overviewCircles").height();
        var svgWidth = $("#overviewCircles").width();

        var getRadius = buildDataValueToAreaRadius(countsByCategory, svgWidth);

        var tooltipDiv = d3.select("#section2Tooltip");

        var groups = overviewCirclesSvg.selectAll("g").data(d3.entries(countsByCategory));
        groups = groups.enter().append("g").merge(groups)
          .attr("transform", function(d) { return "translate("+ hardCodedXValues[d.key] + "," + svgHeight / 2 + ")" })
        groups.append("circle")
          .attr("r", function(d) { return getRadius(d.value) })
          .attr("fill", function(d) { return hardCodedColors[d.key]})
          .on("mouseover", function(d) {
            tooltipDiv.transition()
              .duration(200)
              .style("opacity", 0.9);
            tooltipDiv.html(hardCodedLabels[d.key] + "<br/>" + d.value)
              .style("position", "absolute")
              .style("left", (d3.event.pageX) + "px")
              .style("top", (d3.event.pageY - 28) + "px");
          })
          .on("mouseout", function(d) {
              tooltipDiv.transition()
                .duration(200)
                .style("opacity", 0);
          })
          .exit().remove();

        groups.append("text")
          .attr("text-anchor", "middle")
          .text(function(d) { return hardCodedLabels[d.key] });
      }

      //based on https://bl.ocks.org/guilhermesimoes/e6356aa90a16163a6f917f53600a2b4a
      function buildDataValueToAreaRadius(data, width) {
        var values = d3.values(data);
        var maxValue = d3.max(values);
        var totalCount = d3.sum(values);
        var maxProp = maxValue / totalCount;
        var maxRadius = width * 0.35 * maxProp;
        var maxArea = Math.PI * Math.pow(maxRadius, 2);

        var scale = d3.scaleLinear()
          .domain([0, maxValue])
          .range([0, maxArea]);

        return function radius(d) {
          var area;
          area = scale(d);
          return Math.sqrt(area / Math.PI);
        }
      }


    </script>
  </body>
</html>