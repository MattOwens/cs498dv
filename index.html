<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>US Homicides</title>

    <!--Load jQuery and fullpage tags -->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/3.0.1/fullpage.min.js"></script>

    <!-- load d3 -->
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <!--script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script-->

    <!--We will overide some default styles here -->
    <link rel="stylesheet" href='styles.css'>
    <!-- Adding fullpage.css is essential-->
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/fullPage.js/3.0.1/fullpage.min.css" />
  </head>
  <body>

    <div id="fullpage">
      <div class="section">
        <p>Homicides By State</p>
        <label><input id="showCumulativeCheckbox" type="checkbox" onchange="drawMap()"/>Show Cumulative Totals</label>
        <input type="range" min="2007" max="2017" value="2007" id="yearSlider" oninput="drawMap()" onchange="drawMap()">
        <p id="yearLabel"></p>
        <svg id="yearsvg" width="960", height="600"></svg>
      </div>
      <div class="section">
        <p>Section 2</p>
        <p>
          The previous slide showed the total number of homicides in each state, but not all homicides are the same. In the dataset, each homicide
          is tagged with one of the following attributes:
        </p>
        <ul>
          <li>Closed by arrest: The police reported the case was closed and a suspect had been arrested.</li>
          <li>Close without arrest: The police reported there was sufficient evidence against a suspect, but an arrest was not possible.</li>
          <li>Open/no arrest: All other cases.</li>
        </ul>
        <p>
          This chart shows the relative numbers of each classification through the area of the circles. Mouse over a circle to see the number of 
          homicides in each category. When you're finished, scroll down and we'll combine the information gained in these two slides.
        </p>
        <div id="section2Tooltip" class="tooltip"></div>
        <svg id="overviewCircles" width="960", height="960"></svg>
      </div>
      <div class="section">
        <p>Section 3</p>
        <svg id="stateCircles" width="960", height="960"></svg>
      </div>
    </div>

    <!--Custom script -->
    <script type="text/javascript">
      $(document).ready(function(){
        $("#fullpage").fullpage({
          //fullpage options
          licenseKey:"OPEN-SOURCE-GPLV3-LICENSE"
        });  
        loadData();
        drawOverViewCirlces();
      });

      function loadData() {
        // this is run after page is ready so I can select all the svg elements I need
        yearSvg = d3.select("#yearsvg");
        overviewCirclesSvg = d3.select("#overviewCircles");

        /*d3.queue()
        .defer(d3.csv, "count_by_year_and_state.csv", buildHomicides)
        .await(usLoaded);
          */
        d3.csv("count_by_year_and_state.csv", buildHomicides);
      }

      //This chunk is the chart on the first slide
      var color = d3.scaleThreshold();
      var homicidesState = {};
      var yearSvg = d3.select("#yearsvg");
      var us = {};

      function getCountForState(state, year, showCumulativeTotals) {
        var total = -1;

        if(state in homicidesState) {
          var years = homicidesState[state];

          if(showCumulativeTotals) {
            total = getCumulativeCountForState(state, year);
          }
          else if(year in years) {
            total = parseInt(years[year]);
          }
        }

        return total;
      }

      function getCumulativeCountForState(state, endYear) {
        var total = -1;
        for (checkYear = 2007; checkYear <= endYear; checkYear++) {
          if(checkYear in homicidesState[state]) {
            if(total == -1) total += 1; //first time to get to 0
            total += parseInt(homicidesState[state][checkYear]);
          }
        }
        return total;
      }

      function drawMap() {
        var year = parseInt($("#yearSlider").val());
        var showCumulativeTotals = $("#showCumulativeCheckbox").is(":checked");
        
        if(showCumulativeTotals) {
          $("#yearLabel").text("Years: 2007-" + year);
        }
        else {
          $("#yearLabel").text("Year: " + year);
        }

        var data = {};
        var maxCount = Number.MIN_SAFE_INTEGER;
        var margin = 20;
        var height = $("#yearsvg").height() - 2 * margin; //top and bottom margins
        var width = $("#yearsvg").width() - 2 * margin;
        var maxBarHeight = height - 15;
        

          

        for(var state in homicidesState) {
          var count = getCountForState(state, year, showCumulativeTotals);
          if(count != -1)
            data[state] = count;
          if(count > maxCount)
            maxCount = count;
        }

        var barWidth = 30;

        d3.select("#yearsvg").append("g")
          .attr("transform", "translate(" + margin + "," + margin + ")");

        var x = d3.scaleBand()
          .domain(Object.keys(data))
          .range([0, width])
          .padding(0.1);

        var y = d3.scaleLinear()
          .domain([0, maxCount])
          .range([maxBarHeight, 0]);
        
        var join = yearSvg.selectAll("rect").data(d3.entries(data));
        join.enter().append("rect").merge(join)
          .attr("width", x.bandwidth())
          .attr("height", function(d) { return maxBarHeight - y(d.value) })
          .attr("x", function(d) { return x(d.key) })
          .attr("y", height)
          .attr("fill", "blue")
          .exit().remove();


        // Remove old axes if necessary so there aren't duplicates drawn.
        yearSvg.selectAll(".axis").remove();

        yearSvg.append("g")
          .attr("transform", "translate(0," + height + ")")
          .attr("class", "axis")
          .call(d3.axisBottom(x));
        
        yearSvg.append("g")
          .attr("class", "axis")
          .call(d3.axisLeft(y));
      }
      
      function buildHomicides(data) {
        for(var index in data) {
          var homicideData = data[index];
          var stateId = homicideData.state;
          if(!(stateId in homicidesState)) {
            homicidesState[stateId] = {};
          }
          homicidesState[stateId][homicideData.year] = homicideData.count; 
        }
        drawMap();
      }



      //this chunk is the first set of circles (not broken down by type)

      //harcoded data
      var countsByCategory = {
        arrest: 25674,
        withoutArrest: 2922,
        open: 23583 
      };
      var totalHomicides = countsByCategory.arrest + countsByCategory.withoutArrest + countsByCategory.open;
      var hardCodedColors = {
        arrest: "green",
        withoutArrest: "yellow",
        open: "red"
      };
      var hardCodedXValues = {
        arrest: 220,
        withoutArrest: 500,
        open: 750
      };
      var hardCodedLabels = {
        arrest: "Arrest",
        withoutArrest: "No Arrest",
        open: "Open"
      };

      var overviewCirclesSvg = d3.select("#overviewCircles");

      function drawOverViewCirlces() {
        var svgHeight = $("#overviewCircles").height();
        var svgWidth = $("#overviewCircles").width();

        var getRadius = buildDataValueToAreaRadius(countsByCategory, svgWidth);

        var tooltipDiv = d3.select("#section2Tooltip");

        var groups = overviewCirclesSvg.selectAll("g").data(d3.entries(countsByCategory));
        groups = groups.enter().append("g").merge(groups)
          .attr("transform", function(d) { return "translate("+ hardCodedXValues[d.key] + "," + svgHeight / 2 + ")" });

        groups.append("circle")
          .attr("r", function(d) { return getRadius(d.value) })
          .attr("fill", function(d) { return hardCodedColors[d.key]})
          .on("mouseover", function(d) {
            tooltipDiv.transition()
              .duration(200)
              .style("opacity", 0.9);
            tooltipDiv.html(hardCodedLabels[d.key] + "<br/>" + d.value)
              .style("position", "absolute")
              .style("left", (d3.event.pageX) + "px")
              .style("top", (d3.event.pageY - 28) + "px");
          })
          .on("mouseout", function(d) {
              tooltipDiv.transition()
                .duration(200)
                .style("opacity", 0);
          })
          .exit().remove();

        groups.append("text")
          .attr("text-anchor", "middle")
          .text(function(d) { return hardCodedLabels[d.key] });
      }

      //based on https://bl.ocks.org/guilhermesimoes/e6356aa90a16163a6f917f53600a2b4a
      function buildDataValueToAreaRadius(data, width) {
        var values = d3.values(data);
        var maxValue = d3.max(values);
        var totalCount = d3.sum(values);
        var maxProp = maxValue / totalCount;
        var maxRadius = width * 0.35 * maxProp;
        var maxArea = Math.PI * Math.pow(maxRadius, 2);

        var scale = d3.scaleLinear()
          .domain([0, maxValue])
          .range([0, maxArea]);

        return function radius(d) {
          var area;
          area = scale(d);
          return Math.sqrt(area / Math.PI);
        }
      }


    </script>
  </body>
</html>